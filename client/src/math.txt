// import * as THREE from 'three';

// export function getProjectedPosition(x, y, camera){
//   let cameraNormal = camera.getWorldDirection();
//   let v = new THREE.Vector3(x, y, -1); //on near plane
//   v.unproject(camera);

//   let v2 = new THREE.Vector3(x, y, 1); //on near plane
//   v2.unproject(camera);

//   let v3 = new THREE.Vector3().lerpVectors(v, v2, 0.01);

//   return v3;
// }

// export function planeBetweenPoints(plane: THREE.Plane, v1, v2){
//   let delta1 = plane.distanceToPoint(v1);
//   let delta2 = plane.distanceToPoint(v2);

//   return Math.sign(delta1) != Math.sign(delta2);
// }

// export function pointOnPlane(plane, point, threshold = 1) {
//     return Math.abs(plane.distanceToPoint(point)) < threshold;
// }

// export function planeBetweenPoints2(plane: THREE.Plane, v1, v2) {
//   const EPSILON = 0.00001;

//   let delta1 = plane.distanceToPoint(v1);
//   if (Math.abs(delta1) < EPSILON) {
//       delta1 = 0;
//   }

//   let delta2 = plane.distanceToPoint(v2);

//   if (Math.abs(delta2) < EPSILON) {
//       delta2 = 0;
//   }
//   // console.log('delta1', delta1, 'delta2', delta2);

//   if (delta1 === 0 || delta2 === 0) {
//     // at least one vertex plane, skip
//     return false;
//   }

//   return Math.sign(delta1) !== Math.sign(delta2);
// }

// export function planeBetweenPoints3(plane: THREE.Plane, v1, v2) {
//   const distance1 = plane.distanceToPoint(v1);
//   const distance2 = plane.distanceToPoint(v2);

//   // console.log('planeBetweenPoints3', distance1, distance2);

//   let inner = false;
//   let outer = false;

//   if ( distance1 > 0.00000001) {
//       inner = true;
//   }
//   if (distance1 < -0.00000001) {
//       outer = true;
//   }
//   if (distance2 > 0.00000001) {
//       inner = true;
//   }
//   if (distance2  < -0.00000001) {
//       outer = true;
//   }
//   return inner && outer;
// }

// // https://github.com/substack/point-in-polygon
// export function polygonContains(point, vs){
//   var x = point[0], y = point[1];

//   var inside = false;
//   for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
//       var xi = vs[i][0], yi = vs[i][1];
//       var xj = vs[j][0], yj = vs[j][1];

//       var intersect = ((yi > y) != (yj > y))
//           && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
//       if (intersect) inside = !inside;
//   }

//   return inside;
// }

// // https://github.com/scottglz/distance-to-line-segment/blob/master/index.js
// export function distanceSquaredToLineSegment(lx1, ly1, lx2, ly2, px, py) {
//  var ldx = lx2 - lx1,
//      ldy = ly2 - ly1,
//      lineLengthSquared = ldx*ldx + ldy*ldy;
//  return distanceSquaredToLineSegment2(lx1, ly1, ldx, ldy, lineLengthSquared, px, py);
// }

// export function distanceSquaredToLineSegment2(lx1, ly1, ldx, ldy, lineLengthSquared, px, py) {
//    var t; // t===0 at line pt 1 and t ===1 at line pt 2
//    if (!lineLengthSquared) {
//       // 0-length line segment. Any t will return same result
//       t = 0;
//    }
//    else {
//       t = ((px - lx1) * ldx + (py - ly1) * ldy) / lineLengthSquared;

//       if (t < 0)
//          t = 0;
//       else if (t > 1)
//          t = 1;
//    }

//    var lx = lx1 + t * ldx,
//        ly = ly1 + t * ldy,
//        dx = px - lx,
//        dy = py - ly;
//    return dx*dx + dy*dy;
// }
// export default { getProjectedPosition, planeBetweenPoints, planeBetweenPoints2 };

/////////////////////////////////////////////////////////////////////////////////////////////////
import {Canvas, useThree} from "@react-three/fiber";

const deg2rad = degrees => degrees * (Math.PI / 180);

const Scene = () => {
  useThree(({camera}) => {
    camera.rotation.set(deg2rad(30), 0, 0);
  });
  
  return (
    <Canvas />
  );
};



/**
 * Convert vertical field of view to horizontal field of view, given an aspect
 * ratio. See https://arstechnica.com/civis/viewtopic.php?f=6&t=37447
 *
 * @param vfov - The vertical field of view.
 * @param aspect - The aspect ratio, which is generally width/height of the viewport.
 * @returns - The horizontal field of view.
 */
function vfovToHfov(vfov: number, aspect: number): number {
  const {tan, atan} = Math
  return atan(aspect * tan(vfov / 2)) * 2
}

/**
 * Get the distance from the camera to fit an object in view by either its
 * horizontal or its vertical dimension.
 *
 * @param size - This should be the width or height of the object to fit.
 * @param fov - If `size` is the object's width, `fov` should be the horizontal
 * field of view of the view camera. If `size` is the object's height, then
 * `fov` should be the view camera's vertical field of view.
 * @returns - The distance from the camera so that the object will fit from
 * edge to edge of the viewport.
 */
function _distanceToFitObjectInView(size: number, fov: number): number {
  const {tan} = Math
  return size / (2 * tan(fov / 2))
}

function distanceToFitObjectToView(
  cameraAspect: number,
  cameraVFov: number,
  objWidth: number,
  objHeight: number
): number {
  const objAspect = objWidth / objHeight
  const cameraHFov = vfovToHfov(cameraVFov, cameraAspect)

  let distance: number = 0

  if (objAspect > cameraAspect) {
    distance = _distanceToFitObjectInView(objHeight, cameraVFov)
  } else if (objAspect <= cameraAspect) {
    distance = _distanceToFitObjectInView(objWidth, cameraHFov)
  }

  return distance
}



//solve the issue of phones having increased PPI by doubling canvas size but reduce it back down via CSS
//would work however react three fiber does not have easy access to a generic canvas.
// const createCanvas = (width, height, set2dTransform = true) => {
//   const ratio = Math.ceil(window.devicePixelRatio)
//   const canvas = document.createElement('canvas')
//   canvas.width = width * ratio
//   canvas.height = height * ratio
//   canvas.style.width = `${width}px`
//   canvas.style.height = `${height}px`

//   if(set2dTransform)
//     canvas.getContext('2d').setTransform(ratio, 0, 0, ratio, 0, 0)

//   return canvas
// }

//the below works https://standard.ai/blog/introducing-standard-view-and-react-three-fiber-context-bridge/
// const ContextListeners = React.memo(({
//   contexts,
//   values
// }) => contexts.map(
//     (context, index) => (
//       <ContextListener
//         context={context}
//         values={values}
//         index={index}
//       />
//     )
// ))

// const ContextListener = React.memo(({ context, values, index }) => {
//   values[index] = useContext(context);
//   return null;
// })

// const ContextProviders = memo(({
//   contexts,
//   values,
//   children
// }) => {
//   const [, update] = useState();

//   useFrame(() => update({}));

//   if (!contexts || !values) {
//     return <>{children}</>;
//   }

//   return contexts.reduce(
//     (child, Context, index) => (
//       <Context.Provider value={values[index]}>
//         {child}
//       </Context.Provider>
//     ),
//     children
//   );
// });
// const CanvasWithContextBridge = React.memo(({contexts, canvasStyles, children}) => {
//   const values = useRef([])
//   return(
//     <>
//       <ContextListeners contexts={contexts} values={values.current} />
//       <Canvas gl={{ antialias: true }} style={canvasStyles}>
//         <ContextProviders contexts={contexts} values={values.current}>
//           {children}
//         </ContextProviders>
//       </Canvas>
//     </>
//   )
// })